# Проект: Optimizator Next Gen

## 1. Миссия

Создаем десктопное приложение "Optimizator Next Gen" на базе Electron и TypeScript. Приложение предназначено для глубокой и гибкой обработки шаблонов документов (docx и fdt) с целью их оптимизации и стандартизации. Ключевая особенность проекта — максимальная атомизация логики и динамическая генерация пользовательского интерфейса на основе единого конфигурационного файла `config.json`.

## 2. Роли и методология

- **Архитектор (Пользователь):** Определяет стратегию, цели, функциональные требования и конечную логику продукта. Принимает ключевые архитектурные решения. Учится новым технологиям (TypeScript, Electron) в процессе.
- **Разработчик (LLM):** Является техническим специалистом. Предлагает варианты реализации, пишет код по утвержденному плану, объясняет технические нюансы, обеспечивает качество и чистоту кода.
- **Методология:**
  1.  **Обсуждение → Решение → Код:** Мы не пишем код, пока все детали не согласованы.
  2.  **Итеративная разработка:** Двигаемся маленькими, логичными шагами.
  3.  **Профессиональная этика:** Мы — команда. Не извиняемся, а решаем проблемы.
  4.  **GitHub-ориентированность:** Проект ведется как open-source портфолио с высоким качеством кода и документации.
  5.  **Дневник разработки:** Все ключевые решения фиксируются в `DEV_LOG.md`.

## 3. Ключевые архитектурные принципы

- **Единый источник истины:** Вся конфигурация приложения, включая логику обработки, глобальные настройки документов и даже тема интерфейса, находится в одном файле `config.json`.
- **Трехуровневая архитектура: "Оболочка" → "Оркестратор" → "Ядро"**:
  - **Уровень "Оболочки" (Shell):** Отвечает за всю работу с файловой системой. Включает "Нормализатор" (fdt/docx → docx), "Распаковщик/Запаковщик" (docx ↔ xml) и отладочные инструменты.
  - **Уровень "Оркестратора" (Orchestrator):** Управляет процессом. Получает от "Оболочки" XML-строку, читает `config.json` и последовательно вызывает операции из "Ядра".
  - **Уровень "Ядра" (Core):** "Чистый" обработчик данных. Состоит из набора атомарных, независимых функций, каждая в своем файле. Каждая функция принимает и возвращает XML-строку, выполняя одну единственную операцию (`RegExp`).
- **Динамический UI:** Интерфейс Electron (Renderer) динамически генерируется на основе метаданных из `config.json`. Добавление новой функции в `config.json` автоматически отображает ее в UI без изменения кода фронтенда.
- **Трехуровневый интерфейс:** UI имеет три режима доступа, фильтруя `config.json` по мета-тегам:
  - **User:** Минималистичный вид. Только выбор файлов и запуск.
  - **Developer:** Доступ к настройкам шагов обработки (`processingSteps`).
  - **Settings:** Доступ к глобальным настройкам документа (`documentSettings`).

## 4. Стек технологий

- **Фреймворк:** Electron
- **Язык:** TypeScript
- **Тестирование:** Jest
- **Сборка и зависимости:** `electron-builder` (или аналог), `adm-zip` (или аналог).
- **Среда разработки:** VS Code
- **Система контроля версий:** Git (GitHub)

## 5. Детализация структуры `config.json`

`config.json` имеет три корневых свойства: `themeSettings`, `documentSettings`, `processingSteps`.

- **`themeSettings`**: Объект, описывающий CSS-переменные для темизации UI.
  - _Пример:_ `{"fontFamily": "Inter", "colors": {"background": "#2B2B2B"}}`
- **`documentSettings` / `processingSteps`**: Массивы объектов, где каждый объект ("атом") описывает одну операцию и имеет следующую структуру:
  - `id` (string): Уникальный ID, совпадает с именем файла-модуля. Пример: `"removeFonts"`.
  - `name` (string): Человекочитаемое имя для UI. Пример: `"Удаление информации о шрифтах"`.
  - `description` (string): Краткое описание для UI.
  - `enabled` (boolean): Включена ли операция по умолчанию.
  - `ui` (object): Метаданные для рендеринга в UI.
    - `view` (string): Уровень доступа ('Developer' или 'Settings').
    - `group` (string): Группа для объединения в UI. Пример: `"Очистка"`.
    - `type` (string): Тип элемента управления. Пример: `"boolean"`, `"object"`, `"array"`.
  - `params` (any): Параметры, передаваемые в функцию-обработчик. Структура зависит от операции.

## 6. Ключевые технические регламенты

- **Обработка ошибок:** При возникновении ошибки во время обработки одного файла в пакетном режиме, процесс не останавливается. Ошибка детально логируется, "проблемный" файл пропускается, и обработка переходит к следующему файлу.
- **IPC-протокол (Main ↔ Renderer):**
  - **Запуск (Renderer → Main):** Фронтенд вызывает один метод, например, `window.api.startProcessing(filePaths)`, где `filePaths` — массив путей к файлам. Текущий `config.json` читается на стороне Main процесса.
  - **Статус (Main → Renderer):** Бэкенд отправляет на фронтенд сообщения о прогрессе в формате `{ channel: 'update-status', payload: { message: 'Обработка файла X...', step: 'Удаление шрифтов' } }`.
- **Тестирование:** Каждая функция-обработчик из **Уровня "Ядра"** должна иметь соответствующий ей файл с юнит-тестами (`*.test.ts`), написанными с использованием фреймворка **Jest**. Тесты должны покрывать как стандартное поведение, так и крайние случаи. Это является обязательным требованием для обеспечения стабильности динамического конвейера обработки.
