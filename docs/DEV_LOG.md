<!-- Файл: docs/DEV_LOG.md -->

# Дневник разработки "Optimizator Next Gen"

### Сессия 5: Структурирование документации и промптов (01.10.2025)

- **Задача:** Создать систему документации, которая разделяет универсальные правила работы с LLM и специфику конкретного проекта, обеспечивая переиспользование в будущих проектах.

- **Проблема:** Существующий промпт содержал смесь общих правил взаимодействия и специфичных для проекта деталей. Это затрудняло:

  - Переиспользование правил в других проектах
  - Быструю навигацию по документации
  - Восстановление контекста при работе с разными моделями

- **Решение:** Документация была разделена на два независимых файла:

  **PROMPT.md (универсальный промпт):**

  - Философия взаимодействия (диалог, обучение, критика)
  - Роли участников (Архитектор/Пользователь, Технический консультант/LLM)
  - **Манера общения (критично):**
    - Запрет на извинения (фокус на решении, а не на формальностях)
    - Перепроверка кода перед отправкой
    - Требование задавать вопросы вместо угадывания
  - Формат работы с кодом (целые файлы, имя файла в начале)
  - **Единообразие стиля проектов:**
    - Стандартная структура документации
    - Правила оформления Markdown
    - Структура кода (шапки файлов, порядок элементов, именование)
    - Комментарии (JSDoc, префиксы WHY/ASSUME/TODO/FIXME)
    - Git-практики (Conventional Commits)
    - Конфигурационные файлы
  - Когда останавливаться и задавать вопросы
  - Обработка ошибок
  - Тестирование
  - **Контрольный чеклист** перед ответом

  **PROJECT.md (специфика проекта):**

  - Миссия проекта Optimizator Next Gen
  - Стек технологий (Electron, TypeScript, Jest)
  - Архитектурные принципы (единый источник истины, трёхуровневая архитектура)
  - Структура config.json
  - Технические регламенты (IPC-протокол, безопасность, логирование)
  - Структура проекта
  - Специфичные требования к коду (шаблоны для Core/Orchestrator/Shell)
  - Контекст для восстановления (текущие задачи, нерешённые вопросы)
  - Журнал изменений PROJECT.md

- **Ключевые нововведения:**

  1. **Запрет на извинения:** LLM больше не тратит время на формальности, сразу даёт исправленный код или решение.

  2. **Имя файла в начале:** Каждый файл начинается с комментария вида `// Файл: src/core/steps/removeFonts.ts` или `<!-- Файл: docs/PROMPT.md -->`. Это устраняет путаницу при работе с несколькими файлами одновременно.

  3. **Craft не используется:** Зафиксировано, что инструмент Craft часто даёт ошибки. Весь код передаётся в обычных code-блоках Markdown.

  4. **Единообразие стиля:** Установлены чёткие требования к:

     - Структуре файлов (порядок импортов, типов, функций)
     - Именованию (camelCase для функций, UPPER_SNAKE_CASE для констант)
     - Комментариям (префиксы для разных типов комментариев)
     - Git-коммитам (Conventional Commits)

  5. **Контрольный чеклист:** LLM проверяет 7 пунктов перед каждым ответом с кодом.

- **Технические детали:**

  - Оба файла используют версионирование (PROMPT.md v1.0.0, PROJECT.md v0.3.0)
  - В PROJECT.md добавлена ссылка на базовый PROMPT.md
  - Раздел "Контекст для восстановления" в PROJECT.md служит для переноса информации между сессиями и моделями
  - Журналы изменений в обоих файлах позволяют отслеживать эволюцию правил

- **Результат:**

  - Создана масштабируемая система документации
  - PROMPT.md можно копировать в любой новый проект без изменений
  - PROJECT.md содержит только уникальную информацию о проекте
  - Манера общения LLM стала более эффективной (без извинений, с вопросами)
  - Установлены единые стандарты кода для всех будущих проектов

- **Вывод:** Документация проекта переведена на новый уровень. Созданная структура не только облегчает текущую работу, но и создаёт фундамент для всех будущих проектов. Универсальный промпт станет "стандартом качества" взаимодействия с LLM, обеспечивая консистентность и профессионализм кодовой базы.

---

### Сессия 4: Битва за UI и переход на esbuild (25.08.2025)

- **Задача:** Отобразить в окне Electron динамический список шагов обработки из `config.json`.

- **Проблема:** Несмотря на корректность кода, интерфейс постоянно зависал на стадии "Загрузка...". Это инициировало одну из самых долгих и глубоких отладочных сессий в проекте.

- **Хроника отладки (гипотезы и тупики):**

  1.  **Гонка состояний (`DOMContentLoaded`):** Первая гипотеза заключалась в том, что `renderer.ts` выполняется до загрузки HTML. Были добавлены соответствующие слушатели, что не решило проблему.

  2.  **Конфигурация безопасности (`contextIsolation`):** Вторая гипотеза — неправильные настройки безопасности в `webPreferences`. Конфигурация была приведена к современным стандартам Electron, но ошибка осталась.

  3.  **Конфликт модулей (`import`/`export`):** Третья гипотеза — TypeScript-компилятор генерирует `exports` в `renderer.js`, что недопустимо в браузере. Были предприняты попытки полностью изолировать `renderer.ts`, убрав все импорты. Это приводило к новым ошибкам типов.

  4.  **Разделение `tsconfig`:** Четвертая, почти верная гипотеза — конфликт сред выполнения. Была предпринята попытка создать два `tsconfig` файла. Это привело к новым ошибкам разрешения модулей, показав, что `tsc` в одиночку не справляется с этой задачей.

- **Финальный диагноз и решение:**

  - **Коренная причина:** Фундаментальный конфликт между системами модулей: `CommonJS` для бэкенда (Node.js) и `ES Modules` для фронтенда (браузер). Пытаться скомпилировать обе среды одним инструментом (`tsc`) было архитектурной ошибкой.

  - **Решение:** В проект был добавлен профессиональный сборщик `esbuild`. Система сборки в `package.json` была полностью переработана:

    - `tsc -p tsconfig.json` теперь отвечает **только** за компиляцию бэкенда (`main.ts`, `preload.ts`).

    - `esbuild` теперь отвечает **только** за сборку и бандлинг фронтенда (`renderer.ts`) в единый, совместимый с браузером файл.

- **Результат:**

  - Все ошибки компиляции и выполнения устранены.

  - Приложение успешно запускается и корректно отображает динамический интерфейс.

  - Система сборки проекта приведена к промышленным стандартам, что делает ее надежной и масштабируемой.

- **Вывод:** Сложная проблема была решена не исправлением кода, а исправлением **архитектуры процесса сборки**. Это ключевой опыт для дальнейшего развития проекта.

---

### Сессия 3: Создание "Оболочки" - Фронтенд разработчика (25.08.2025)

- **Задача:** Разработать и интегрировать первую версию графического пользовательского интерфейса (GUI) на базе Electron, чтобы заменить консольный запуск и обеспечить интерактивное управление процессом.

- **Действия:**

  1.  Установлены ключевые зависимости для GUI: `electron`, `electron-builder`.

  2.  `package.json` и `tsconfig.json` были кардинально переработаны для поддержки сборки и запуска Electron-приложения.

  3.  **Реализована архитектура фронтенда:**

      - **`index.html`**: Создан как контейнер для интерфейса.

      - **`renderer.ts`**: Написан скрипт, отвечающий за логику внутри окна. Его ключевая задача — **динамическая генерация UI** (групп и чекбоксов) напрямую из `config.json`.

      - **`preload.ts`**: Создан защищенный "мост" для безопасного вызова функций бэкенда из фронтенда (`ipcRenderer`, `contextBridge`).

  4.  **`main.ts` был полностью перестроен:**

      - Из консольного скрипта он превратился в главный процесс Electron, управляющий жизненным циклом приложения и созданием окна (`BrowserWindow`).

      - Реализованы обработчики `ipcMain` для связи с фронтендом (`get-config`, `start-processing`).

      - Логирование было перенаправлено из `console.log` в окно приложения через канал `update-status`.

  5.  **Столкнулись с проблемами:**

      - Возникла лавина ошибок типизации TypeScript (`TS2322`, `TS2554`, `TS7006` и др.) из-за строгих правил компилятора (`"strict": true`) и отсутствия явных типов в новой кодовой базе.

      - **Решение:** Проведен полный рефакторинг `main.ts`, `preload.ts`, и `renderer.ts` с добавлением всех необходимых интерфейсов (`Config`, `ProcessingStep`, `IElectronAPI`), проверкой на `null` и корректной обработкой ошибок типа `unknown`.

      - Обнаружена логическая ошибка при попытке вызова одного `ipcMain.handle` из другого.

      - **Решение:** Проблема решена созданием отдельной переиспользуемой функции `readConfig()`.

- **Результат:**

  - Получено рабочее десктопное приложение с графическим интерфейсом.

  - Интерфейс успешно строится на лету на основе `config.json`, что доказывает жизнеспособность ключевого архитектурного принципа.

  - Пользователь может выбирать файлы через системный диалог и запускать конвейер обработки нажатием кнопки.

  - Лог обработки в реальном времени отображается в окне приложения.

- **Вывод:** Проект успешно перешел от стадии консольной утилиты к стадии десктопного приложения. Создана надежная база для дальнейшего развития как "Ядра" (добавления новых атомов), так и "Оболочки" (реализации других уровней доступа UI).

---

## Сессия 2: Настройка окружения и первая функция (24.08.2025)

- **Задача:** Настроить рабочее окружение для TypeScript-проекта и создать первую атомарную функцию `removeStyles` с тестами.

- **Действия:**

  1. Инициализирован `npm` в проекте (`package.json`).

  2. Установлены ключевые dev-зависимости: `typescript`, `jest`, `ts-jest`, `@types/jest`.

  3. Созданы и настроены конфигурационные файлы `tsconfig.json` и `jest.config.js`.

  4. **Столкнулись с проблемами:**

     - Предупреждения `EBADENGINE` из-за нестабильной версии Node.js (v23).

     - **Решение:** Установлен `nvm-windows` для управления версиями, выполнен переход на стабильную LTS-версию (v22.18.0).

     - Конфликт `PATH` из-за старой глобальной установки Node.js.

     - **Решение:** Удалена глобальная версия Node.js через "Установку и удаление программ".

     - Визуальные ошибки в VS Code, не связанные с кодом.

     - **Решение:** Диагностирован конфликт версий TypeScript в VS Code, проблема решена выбором "Workspace's Version".

     - Ошибки `Jest` "No tests found".

     - **Решение:** Скорректирован `jest.config.js` для явного указания пути к тестовым файлам.

- **Результат:**

  - Рабочее окружение полностью настроено.

  - Создана первая атомарная функция `removeStyles` и покрыта тремя тестами в `removeStyles.test.ts`.

  - Команда `npm test` успешно выполняется, все тесты проходят.

- **Вывод:** "Конвейер" для разработки и тестирования готов к работе.

---

## Сессия 1: Архитектурное проектирование (23.08.2025)

- Определена миссия, роли (Архитектор/Пользователь, Разработчик/LLM) и стек технологий (Electron, TypeScript).

- Утверждена трехуровневая архитектура: "Оболочка" -> "Оркестратор" -> "Ядро".

- Спроектирована структура `config.json` с тремя корневыми ключами: `themeSettings`, `documentSettings`, `processingSteps`.

- Детализирована структура "атома" (объекта операции) с полями `id`, `name`, `description`, `enabled`, `ui`, `params`.

- Спроектированы первые атомарные функции: `removeStyles`, `setDefaultStyle`, `removeParagraphSpacing`, `removeFirstLineIndentation`, `setPageMargins`.

- После обсуждения принято решение об агрегации функций по удалению отступов, но затем, следуя принципу атомизации, вернулись к раздельным модулям.

- Утверждена гибридная модель для управления стилями: быстрая (замена `styles.xml` из шаблона) и гибкая (генерация `styles.xml` из `config.json`).

- Спроектирован "Режим отладки" (Developer Mode) для удобства тестирования, отображающий все настройки на одном экране.
